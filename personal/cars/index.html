 <canvas id="myCanvas" width="800" height="600" style="background:#333; border: 5px solid #555;"></canvas>
<script>
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
window.addEventListener("keydown", (e) => { keys[e.key] = true; });
window.addEventListener("keyup", (e) => { keys[e.key] = false; });

const car = {
    x: 400, y: 300, w: 30, h: 50, speed: 3, angle: 0,
    sensors: [] 
};

// 1. GENERATE 100 SENSORS (CS: Iteration)
for (let i = 0; i < 100; i++) {
    car.sensors.push({
        // Divide the full circle (2 * PI) into 100 parts
        angle: (i / 100) * Math.PI * 2, 
        length: 50, 
        reading: null
    });
}

const walls = [
    { x: 0, y: 0, w: 800, h: 10 },    { x: 0, y: 590, w: 800, h: 10 },
    { x: 0, y: 0, w: 10, h: 600 },    { x: 790, y: 0, w: 10, h: 600 },
    { x: 300, y: 200, w: 200, h: 40 }, { x: 100, y: 400, w: 40, h: 150 }
];

function animate() {
    canvas.height = 600; 

    // 2. PERCEPTION LAYER
    let isSensingWall = false;
    let forwardBlocked = false;

    car.sensors.forEach(s => {
        const rayAngle = s.angle + car.angle;
        const endX = car.x + Math.sin(rayAngle) * s.length;
        const endY = car.y - Math.cos(rayAngle) * s.length;

        // Collision Check
        s.reading = walls.find(w => 
            endX > w.x && endX < w.x + w.w &&
            endY > w.y && endY < w.y + w.h
        );

        if (s.reading) {
            isSensingWall = true;
            // Specifically check if the "forward-facing" sensors are blocked
            // Angles near 0 (front) or 2*PI (also front)
            if (s.angle < 0.5 || s.angle > 5.8) {
                forwardBlocked = true;
            }
        }

        // Draw Sensors (using thin lines for performance/cleanliness)
        ctx.beginPath();
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = s.reading ? "red" : "rgba(144, 238, 144, 0.3)";
        ctx.moveTo(car.x, car.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    });

    // 3. CONTROL LAYER
    if (keys.ArrowLeft)  { car.angle -= 0.05; }
    if (keys.ArrowRight) { car.angle += 0.05; }

    if (keys.ArrowUp && !forwardBlocked) {
        car.x += Math.sin(car.angle) * car.speed;
        car.y -= Math.cos(car.angle) * car.speed;
    }
    
    if (keys.ArrowDown) {
        car.x -= Math.sin(car.angle) * car.speed;
        car.y += Math.cos(car.angle) * car.speed;
    }

    // 4. RENDERING LAYER
    ctx.fillStyle = "white";
    walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

    ctx.save();
    ctx.translate(car.x, car.y);
    ctx.rotate(car.angle);
    ctx.fillStyle = forwardBlocked ? "orange" : "blue";
    ctx.fillRect(-car.w/2, -car.h/2, car.w, car.h);
    ctx.restore();

    requestAnimationFrame(animate);
}
animate();
</script>